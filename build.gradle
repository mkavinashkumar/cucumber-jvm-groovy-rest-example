import groovyx.gpars.GParsPool

apply plugin: 'groovy'
apply plugin: 'idea'

//build stuff
sourceCompatibility = 1.6
targetCompatibility = 1.6

configurations {
    cucumberRuntime {
        extendsFrom testRuntime
    }
}

task cucumber() {
    dependsOn assemble
    doLast {
        javaexec {
            main = "cucumber.api.cli.Main"
            classpath = configurations.cucumberRuntime
            args = ['-f', 'pretty', '--glue', 'src/test/groovy', 'src/test/resources']
        }
    }
}

buildscript {
    repositories {
        mavenCentral()
    }

    dependencies {
        classpath "org.codehaus.gpars:gpars:1.1.0"
    }
}

dependencies {
    // Groovy library for groovy building!
    groovy 'org.codehaus.groovy:groovy-all:2.1.0'
    groovy 'org.codehaus.groovy.modules.http-builder:http-builder:0.6'
    groovy 'org.slf4j:slf4j-api:1.7.+'
    groovy 'org.slf4j:slf4j-log4j12:1.7.5'

    /*
   In order to work around a really flagrant bug ( http://issues.gradle.org/browse/GRADLE-732 )
   You have to create a configuration that includes the jar.archivePath (the jar.archivePath is created by the java plugin)
   and give it the same name as the cucumberRuntime configuration, or name it something different and have the cucumberRuntime
   configuration extend from it as well.

   VERY ANNOYING BUG
    */
    cucumberRuntime files("${jar.archivePath}")

    testCompile 'junit:junit:4.11'
    testCompile 'info.cukes:cucumber-junit:1.1.2'
    testCompile 'info.cukes:cucumber-groovy:1.1.2'
}

repositories {
    mavenCentral()
}

def concurrentMethod(String fileName, String threadName) {
    logger.quiet "FileName: $fileName, ThreadName: $threadName"
    cucumber.execute()
}

String getThreadName(names) {
    String currentName = Thread.currentThread().name
    if (!names.contains(currentName)) names << currentName

    "t${names.indexOf(currentName).toString().padLeft(2, '0')}"
}


task run << {
    def cores   = Runtime.runtime.availableProcessors()
    def threads = 10
    println "    > Using $threads threads on $cores cores..."
    def names = []
    GParsPool.withPool(threads) {
        def features = fileTree(dir: 'src/test/resources').include '**/*.feature'
        features.eachParallel { File file ->
            def name = getThreadName(names)
            logger.quiet "File: ${file.name}"
            concurrentMethod(file.name, name)
        }
    }
    logger.quiet("Run complete!")
}